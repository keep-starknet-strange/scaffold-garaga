{"noir_version":"1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95","hash":"17014884236865514219","abi":{"parameters":[{"name":"secret_key","type":{"kind":"field"},"visibility":"private"},{"name":"input","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"public_key","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use poseidon::poseidon::bn254::hash_2;\n\nfn main(secret_key: Field, input: u32, public_key: pub Field, nullifier: pub Field) {\n    // Check that the input is a perfect square\n    // Safety: it doesn't matter how we obtained the square root\n    let sqrt_input = unsafe { sqrt(input) };\n    assert(sqrt_input * sqrt_input == input);\n\n    // Check that the public key is valid\n    assert(hash_2([secret_key, secret_key]) == public_key);\n\n    // Check that the nullifier is valid\n    let nonce = [secret_key, input as Field];\n    assert(hash_2(nonce) == nullifier);\n}\n\n/// Simple binary search-style integer square root\nunconstrained fn sqrt(x: u32) -> u32 {\n    let mut low: u64 = 1;\n    let mut high: u64 = x as u64;\n\n    loop {\n        let mid = (low + high) / 2;\n        let val = mid * mid;\n\n        if val <= x as u64 {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n\n        if low > high {\n            break;\n        }\n    }\n\n    high as u32\n}\n","path":"/Users/michaelzaikin/scaffold-garaga/circuit/src/main.nr"},"55":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/Users/michaelzaikin/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"56":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/Users/michaelzaikin/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"57":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/Users/michaelzaikin/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"expression_width":{"Bounded":{"width":4}}}